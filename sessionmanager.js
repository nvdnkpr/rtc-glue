/* jshint node: true */
/* global io: false */
'use strict';

var eve = require('eve');
var rtc = require('rtc');

/**
  ### SessionManager

  The SessionManager class assists with interacting with the signalling
  server and creating peer connections between valid parties.  It uses
  eve to create a decoupled way to get peer information.

**/
function SessionManager(config) {
  if (! (this instanceof SessionManager)) {
    return new SessionManager(config);
  }

  // initialise the room and our role
  this.room = config.room;
  this.role = config.role;

  // save the config
  this.cfg = config;

  // initialise our peers list
  this.peers = {};

  // create our signalling interface
  this.signaller = rtc.signaller(io.connect(config.signalhost), {
    dataEvent: 'message',
    openEvent: 'connect'
  });

  // hook up signaller events
  this._bindEvents(this.signaller);
}

module.exports = SessionManager;

/**
  #### announce()

  Announce ourselves on the signalling channel
**/
SessionManager.prototype.announce = function() {
  this.signaller.announce({ room: this.room, role: this.role });
};

/**
  #### broadcast(stream)

  Broadcast a stream to our connected peers.

**/
SessionManager.prototype.broadcast = function(stream) {
  var peers = this.peers;

  // add to existing streams
  Object.keys(peers).forEach(function(peerId) {
    peers[peerId].addStream(stream);
  });

  // when a new peer arrives, add it to that peer also
  eve('glue.peer.join', function(peer) {
    peer.addStream(stream);
  });
};

/* internal methods */

SessionManager.prototype._bindEvents = function(signaller) {
  var mgr = this;

  // TODO: extract the meaningful parts from the config
  // var opts = this.cfg;

  signaller.on('announce', function(data) {
    var ns = 'glue.peer.join.' + (data.role || 'none')
    var peer;
    var monitor;

    // if the room does not match our room
    // OR, we already have an active peer for that id, then abort
    if (data.room !== mgr.room || mgr.peers[data.id]) {
      return;
    }

    // create our peer connection
    peer = mgr.peers[data.id] = rtc.createConnection();

    // couple the connections
    monitor = rtc.couple(peer, { id: data.id }, signaller);

    // wait for the monitor to tell us we have an active connection
    // before attempting to bind to any UI elements
    monitor.once('active', function() {
      // trigger an eve event
      eve(ns, null, peer, data.id);
    });

    // announce ourself
    mgr.announce();
  });

  signaller.on('leave', function(id) {
    // get the peer
    var peer = mgr.peers[id];

    // if this is a peer we know about, then close and send a notification
    if (peer) {
      peer.close();
      mgr.peers[id] = undefined;

      // trigger the notification
      eve('glue.peer.leave', null, peer, id);
    }
  });
};